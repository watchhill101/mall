# 前后端连通登录功能完整流程

## 项目架构概览

### 技术栈
- **后端**: Node.js + Express + MongoDB + Redis + JWT
- **前端**: React 18 + Ant Design + Redux Toolkit + React Router

### 核心功能模块
- JWT双Token认证机制（Access Token + Refresh Token）
- 图片验证码防护
- 用户状态管理
- 路由权限控制

## 1. 后端实现

### 1.1 项目结构
```
backend/
├── app.js                 # 应用入口
├── config/
│   └── index.js          # 配置文件
├── routes/
│   ├── auth.js           # 认证路由
│   └── captcha.js        # 验证码路由
├── utils/
│   ├── jwt.js            # JWT工具类
│   ├── ejwt.js           # Express-JWT中间件
│   └── captcha.js        # 验证码工具
└── moudle/
    └── user/
        └── user.js       # 用户模型
```

### 1.2 核心配置 (config/index.js)
```javascript
require('dotenv').config();

module.exports = {
    jwtSecretKey: process.env.JWT_SECRET_KEY || 'your_jwt_secret_key_2024',
    jwtRefreshSecretKey: process.env.JWT_REFRESH_SECRET_KEY || 'your_jwt_refresh_secret_key_2024',
    secretKeyExpire: parseInt(process.env.JWT_ACCESS_TOKEN_EXPIRE) || 15 * 60, // 15分钟
    refreshSecretKeyExpire: parseInt(process.env.JWT_REFRESH_TOKEN_EXPIRE) || 7 * 24 * 60 * 60, // 7天
    mongodb: {
        uri: process.env.MONGODB_URI || 'mongodb://localhost:27017/mall'
    },
    redis: {
        host: process.env.REDIS_HOST || '127.0.0.1',
        port: parseInt(process.env.REDIS_PORT) || 6379,
        password: process.env.REDIS_PASSWORD || ''
    }
}
```

### 1.3 认证路由 (routes/auth.js)
```javascript
const express = require("express");
const router = express.Router();
const User = require("../moudle/user/user");
const JwtUtil = require("../utils/jwt");
const CaptchaUtil = require("../utils/captcha");
const { jwtAuth, getCurrentUser } = require("../utils/ejwt");

/**
 * 用户登录
 */
router.post("/login", async (req, res) => {
  console.log("🔐 收到登录请求:", req.body);
  
  try {
    const { loginAccount, password, captcha, sessionId } = req.body;

    // 1. 参数验证
    if (!loginAccount || !password) {
      return res.status(400).json({
        code: 400,
        message: "请提供用户名和密码",
        data: null,
      });
    }

    // 2. 验证码验证
    if (!captcha || !sessionId) {
      return res.status(400).json({
        code: 400,
        message: "请提供验证码",
        data: null,
      });
    }

    const isCaptchaValid = await CaptchaUtil.verifyCaptcha(sessionId, captcha);
    if (!isCaptchaValid) {
      return res.status(400).json({
        code: 400,
        message: "验证码错误或已过期",
        data: null,
      });
    }

    // 3. 查找用户
    const user = await User.findOne({ loginAccount });
    if (!user) {
      return res.status(401).json({
        code: 401,
        message: "用户名或密码错误",
        data: null,
      });
    }

    // 4. 验证密码
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      return res.status(401).json({
        code: 401,
        message: "用户名或密码错误",
        data: null,
      });
    }

    // 5. 生成Token对
    const tokens = JwtUtil.generateTokenPair(user);

    // 6. 返回登录结果
    const response = {
      code: 200,
      message: "登录成功",
      data: {
        user: {
          _id: user._id,
          loginAccount: user.loginAccount,
          email: user.email,
          FirstLevelNavigationID: user.FirstLevelNavigationID,
        },
        ...tokens,
      },
    };

    res.json(response);
  } catch (error) {
    console.error("❌ 登录错误:", error);
    res.status(500).json({
      code: 500,
      message: "登录失败: " + error.message,
      data: null,
    });
  }
});

/**
 * 刷新Token
 */
router.post("/refresh", async (req, res) => {
  try {
    const { refreshToken } = req.body;

    if (!refreshToken) {
      return res.status(400).json({
        code: 400,
        message: "Refresh token is required",
        data: null,
      });
    }

    const newTokens = await JwtUtil.refreshAccessToken(refreshToken);

    res.json({
      code: 200,
      message: "Token刷新成功",
      data: newTokens,
    });
  } catch (error) {
    console.error("Refresh token error:", error);
    res.status(401).json({
      code: 401,
      message: "Token刷新失败",
      data: null,
    });
  }
});

/**
 * 用户登出
 */
router.post("/logout", jwtAuth, async (req, res) => {
  try {
    // 删除Redis中的refresh token
    await JwtUtil.deleteRefreshToken(req.auth.userId);

    res.json({
      code: 200,
      message: "登出成功",
      data: null,
    });
  } catch (error) {
    console.error("Logout error:", error);
    res.status(500).json({
      code: 500,
      message: "登出失败",
      data: null,
    });
  }
});

/**
 * 获取当前用户信息
 */
router.get("/me", jwtAuth, getCurrentUser, (req, res) => {
  res.json({
    code: 200,
    message: "获取用户信息成功",
    data: req.currentUser,
  });
});

module.exports = router;
```

### 1.4 JWT中间件 (utils/ejwt.js)
```javascript
const { expressjwt: jwt } = require("express-jwt");
const config = require("../config");
const JwtUtil = require("./jwt");

/**
 * JWT 验证中间件配置
 */
const jwtAuth = jwt({
  secret: config.jwtSecretKey,
  algorithms: ["HS256"],
  userProperty: "auth",
  credentialsRequired: true,
  getToken: function fromHeaderOrQuerystring(req) {
    if (
      req.headers.authorization &&
      req.headers.authorization.split(" ")[0] === "Bearer"
    ) {
      return req.headers.authorization.split(" ")[1];
    } else if (req.query && req.query.token) {
      return req.query.token;
    }
    return null;
  },
});

/**
 * JWT错误处理中间件（支持无感刷新）
 */
const jwtErrorHandler = async (err, req, res, next) => {
  if (err.name === "UnauthorizedError") {
    // 检查是否有refresh token
    const refreshToken = req.headers["x-refresh-token"];

    if (refreshToken) {
      try {
        // 尝试刷新token
        const newTokens = await JwtUtil.refreshAccessToken(refreshToken);

        // 在响应头中返回新的token
        res.setHeader("x-new-access-token", newTokens.accessToken);
        res.setHeader("x-token-refreshed", "true");

        // 重新解析新的token并继续请求
        const decoded = JwtUtil.verifyAccessToken(newTokens.accessToken);
        req.auth = decoded;

        return next();
      } catch (refreshError) {
        return res.status(401).json({
          code: 401,
          message: "Token已过期且刷新失败，请重新登录",
          data: null,
        });
      }
    }

    return res.status(401).json({
      code: 401,
      message: "Token 验证失败",
      data: null,
    });
  }
  next(err);
};

module.exports = {
  jwtAuth,
  jwtErrorHandler,
  // ... 其他中间件
};
```

## 2. 前端实现

### 2.1 项目结构
```
frontend/src/
├── api/
│   └── auth/
│       └── index.js      # 认证API
├── components/
│   ├── Login/
│   │   └── login.jsx     # 登录组件
│   └── Captcha/          # 验证码组件
├── store/
│   ├── index.js          # Store配置
│   └── reducers/
│       └── userSlice.js  # 用户状态管理
├── utils/
│   ├── request.js        # HTTP请求封装
│   └── auth.js           # Token管理
└── router/
    └── index.js          # 路由配置
```

### 2.2 HTTP请求封装 (utils/request.js)
```javascript
import Axios from 'axios'
import { getToken } from '../utils/auth'
import { message } from 'antd'

const BASE_URL = process.env.NODE_ENV === 'production' ? '/api' : '/api'
const TIME_OUT = 20000

const instance = Axios.create({
  baseURL: BASE_URL,
  timeout: TIME_OUT
})

// 不需要token的接口白名单
const whiteList = ['/auth/login', '/auth/refresh', '/captcha/generate', '/captcha/verify', '/captcha/refresh']

// 请求拦截器
instance.interceptors.request.use(
  (config) => {
    console.log('📤 发送请求:', config.method?.toUpperCase(), config.url, config.data);
    
    if (config.url && typeof config.url === 'string') {
      if (!whiteList.includes(config.url)) {
        let token = getToken()
        if (token && token.length > 0) {
          config.headers && (config.headers['Authorization'] = `Bearer ${token}`)
          console.log('🔑 添加 Token:', token.substring(0, 20) + '...');
        }
      } else {
        console.log('⚪ 白名单接口，跳过 Token 验证');
      }
    }
    return config
  },
  (error) => {
    console.error('📤 请求拦截器错误:', error);
    return Promise.reject(error)
  }
)

// 响应拦截器
export function setResponseInterceptor(store, login, logout) {
  instance.interceptors.response.use(
    (response) => {
      console.log('📥 收到响应:', response.status, response.data);
      
      // 处理后端返回的数据格式
      if (response.data && response.data.code !== undefined) {
        if (response.data.code === 200) {
          console.log('✅ 请求成功:', response.data);
          return response.data
        } else {
          const errMsg = response.data.message || '请求失败'
          console.error('❌ 业务错误:', errMsg);
          message.error(errMsg)
          return Promise.reject(new Error(errMsg))
        }
      }
      return response.data || response
    },
    (error) => {
      console.error('请求错误:', error)
      if (error.code === 'ECONNABORTED') {
        message.error('请求超时，请检查网络连接')
      } else if (error.response) {
        const status = error.response.status
        if (status === 404) {
          message.error('请求的资源不存在')
        } else if (status === 500) {
          message.error('服务器内部错误')
        } else if (status === 504) {
          message.error('网关超时，请检查后端服务')
        } else {
          message.error(`请求失败: ${status}`)
        }
      } else {
        message.error('网络错误，请检查连接')
      }
      return Promise.reject(error)
    }
  )
}

export default instance
```

### 2.3 Token管理 (utils/auth.js)
```javascript
// 设置token键值
const TokenKey = 'ACCESS-TOKEN'
const RefreshTokenKey = 'REFRESH-TOKEN'

/**
 * 获取token
 */
const getToken = () => {
  return window.localStorage.getItem(TokenKey)
}

/**
 * 设置token
 */
const setToken = (token) => {
  return window.localStorage.setItem(TokenKey, token)
}

/**
 * 移除token
 */
const removeToken = () => {
  return window.localStorage.removeItem(TokenKey)
}

/**
 * 获取刷新token
 */
const getRefreshToken = () => {
  return window.localStorage.getItem(RefreshTokenKey)
}

/**
 * 设置刷新token
 */
const setRefreshToken = (token) => {
  return window.localStorage.setItem(RefreshTokenKey, token)
}

/**
 * 移除刷新token
 */
const removeRefreshToken = () => {
  return window.localStorage.removeItem(RefreshTokenKey)
}

export { 
  getToken, 
  setToken, 
  removeToken, 
  getRefreshToken, 
  setRefreshToken, 
  removeRefreshToken 
}
```

### 2.4 认证API (api/auth/index.js)
```javascript
import request from '@/utils/request'

const apiMap = {
  login: loginAPI,
  logout: logoutAPI,
  refreshToken: refreshTokenAPI,
  getUserInfo: getUserInfoAPI
}

export default apiMap

// 登录接口
function loginAPI(data) {
  return request({
    url: '/auth/login',
    method: 'POST',
    data
  })
}

// 退出登录
function logoutAPI() {
  return request({
    url: '/auth/logout',
    method: 'POST'
  })
}

// 刷新token
function refreshTokenAPI(refreshToken) {
  return request({
    url: '/auth/refresh',
    method: 'POST',
    data: { refreshToken }
  })
}

// 获取用户信息
function getUserInfoAPI() {
  return request({
    url: '/auth/me',
    method: 'GET'
  })
}
```

### 2.5 用户状态管理 (store/reducers/userSlice.js)
```javascript
import { createSlice } from '@reduxjs/toolkit'
import { 
  getRefreshToken, 
  getToken, 
  setRefreshToken, 
  setToken, 
  removeToken, 
  removeRefreshToken 
} from '@/utils/auth'

/**
 * 创建用户状态切片
 */
const userSlice = createSlice({
  name: 'user',
  initialState: () => {
    const token = getToken() || null
    const refreshToken = getRefreshToken() || null
    return {
      token,
      refreshToken,
      userinfo: { 
        avatar: null,
        username: '',
        email: ''
      }
    }
  },
  reducers: {
    login(state, action) {
      state.token = action.payload.token
      state.refreshToken = action.payload.refreshToken
      // 持久化存储
      setToken(state.token)
      setRefreshToken(state.refreshToken)
    },
    setUserinfo(state, action) {
      const { payload } = action
      state.userinfo = payload
    },
    logout(state, action) {
      state.token = null
      state.refreshToken = null
      state.userinfo = { 
        avatar: null,
        username: '',
        email: ''
      }
      // 清除存储
      removeToken()
      removeRefreshToken()
    }
  }
})

export const { login, setUserinfo, logout } = userSlice.actions

// 异步登录方法
export const loginAsync = (payload) => async (dispatch) => {
  try {
    console.log('🚀 发起登录请求:', payload);
    
    const authAPI = await import('@/api/auth')
    const response = await authAPI.default.login(payload)
    
    console.log('📡 登录响应:', response);
    
    if (response.code === 200) {
      const loginData = {
        token: response.data.accessToken,
        refreshToken: response.data.refreshToken
      }
      
      console.log('💾 保存登录数据:', loginData);
      dispatch(login(loginData))
      
      // 保存用户信息
      if (response.data.user) {
        const userInfo = {
          username: response.data.user.loginAccount,
          email: response.data.user.email,
          avatar: null,
          userId: response.data.user._id
        };
        
        console.log('👤 保存用户信息:', userInfo);
        dispatch(setUserinfo(userInfo))
      }
      
      return loginData
    } else {
      throw new Error(response.message || '登录失败')
    }
  } catch (error) {
    console.error('❌ 登录失败:', error);
    
    // 错误处理
    if (error.code === 'ECONNABORTED') {
      throw new Error('请求超时，请检查网络连接');
    } else if (error.response) {
      const status = error.response.status;
      if (status === 401) {
        throw new Error('用户名或密码错误');
      } else if (status === 500) {
        throw new Error('服务器内部错误，请稍后重试');
      } else {
        throw new Error(`请求失败 (${status}): ${error.response.data?.message || '未知错误'}`);
      }
    } else if (error.message) {
      throw error;
    } else {
      throw new Error('网络连接失败，请检查网络设置');
    }
  }
}

export default userSlice
```

### 2.6 登录组件 (components/Login/login.jsx)
```javascript
import React, { useState, useCallback, useRef } from "react";
import { Button, Checkbox, Form, Input, message } from "antd";
import { useDispatch } from "react-redux";
import { useNavigate } from "react-router-dom";
import { loginAsync } from "@/store/reducers/userSlice";
import CaptchaComponent from "@/components/Captcha";
import styles from "./login.module.scss";

const LoginMine = () => {
  const [loading, setLoading] = useState(false);
  const [captchaData, setCaptchaData] = useState(null);
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  const refreshTimeoutRef = useRef(null);
  const dispatch = useDispatch();
  const navigate = useNavigate();

  // 处理验证码变化
  const handleCaptchaChange = useCallback((data) => {
    console.log('🎯 验证码数据更新:', data);
    setCaptchaData(data);
  }, []);

  // 处理登录提交
  const onFinish = async (values) => {
    // 验证码验证
    if (!captchaData || !captchaData.sessionId) {
      message.error('请先获取验证码');
      return;
    }

    if (!values.captcha) {
      message.error('请输入验证码');
      return;
    }

    setLoading(true);
    console.log("🔐 开始登录:", values);

    try {
      const result = await dispatch(
        loginAsync({
          loginAccount: values.username,
          password: values.password,
          captcha: values.captcha,
          sessionId: captchaData.sessionId
        })
      );

      console.log("✅ 登录成功:", result);
      message.success("登录成功！");

      // 延迟跳转
      setTimeout(() => {
        navigate("/");
      }, 1000);
    } catch (error) {
      console.error("❌ 登录失败:", error);
      message.error(error.message || "登录失败，请检查用户名和密码");
      
      // 登录失败后刷新验证码（防抖处理）
      if (refreshTimeoutRef.current) {
        clearTimeout(refreshTimeoutRef.current);
      }
      
      refreshTimeoutRef.current = setTimeout(() => {
        console.log('🔄 登录失败，触发验证码刷新');
        setRefreshTrigger(prev => prev + 1);
      }, 100);
      
    } finally {
      setLoading(false);
    }
  };

  const onFinishFailed = (errorInfo) => {
    console.log("Failed:", errorInfo);
  };

  // 组件卸载时清理定时器
  React.useEffect(() => {
    return () => {
      if (refreshTimeoutRef.current) {
        clearTimeout(refreshTimeoutRef.current);
      }
    };
  }, []);

  return (
    <div className={styles.loginForm}>
      <Form
        name="basic"
        layout="vertical"
        initialValues={{
          remember: true,
          username: "admin",
          password: "123456",
        }}
        onFinish={onFinish}
        onFinishFailed={onFinishFailed}
        autoComplete="off"
        className={styles.form}
      >
        <Form.Item
          label="用户名"
          name="username"
          rules={[{ required: true, message: "请输入用户名!" }]}
        >
          <Input 
            placeholder="请输入用户名" 
            size="large"
            className={styles.input}
          />
        </Form.Item>

        <Form.Item
          label="密码"
          name="password"
          rules={[{ required: true, message: "请输入密码!" }]}
        >
          <Input.Password 
            placeholder="请输入密码" 
            size="large"
            className={styles.input}
          />
        </Form.Item>

        <Form.Item
          label="验证码"
          name="captcha"
          rules={[{ required: true, message: "请输入验证码!" }]}
        >
          <div className={styles.captchaInputContainer}>
            <Input 
              placeholder="请输入验证码" 
              size="large"
              maxLength={4}
              className={styles.captchaInput}
            />
            <div className={styles.captchaImageContainer}>
              <CaptchaComponent 
                onCaptchaChange={handleCaptchaChange}
                refreshTrigger={refreshTrigger}
              />
            </div>
          </div>
        </Form.Item>

        <Form.Item name="remember" valuePropName="checked">
          <Checkbox className={styles.checkbox}>记住密码</Checkbox>
        </Form.Item>

        <Form.Item>
          <Button 
            type="primary" 
            htmlType="submit" 
            loading={loading} 
            size="large"
            block
            className={styles.submitButton}
          >
            登录
          </Button>
        </Form.Item>
      </Form>
    </div>
  );
};

export default LoginMine;
```

## 3. 完整登录流程

### 3.1 登录流程图
```
用户输入 → 前端验证 → 发送请求 → 后端验证 → 生成Token → 返回结果 → 前端存储 → 跳转页面
    ↓           ↓           ↓           ↓           ↓           ↓           ↓           ↓
1. 用户名    2. 表单      3. HTTP     4. 验证码    5. JWT      6. 登录     7. 本地     8. 路由
   密码        验证        POST        用户名       双Token     响应        存储        跳转
   验证码                  请求        密码验证     生成        数据        Token       首页
```

### 3.2 详细步骤说明

#### 步骤1: 用户输入
- 用户在登录页面输入用户名、密码
- 获取并输入图片验证码
- 点击登录按钮

#### 步骤2: 前端验证
- Form组件进行基础表单验证
- 检查验证码是否已获取
- 验证通过后调用登录API

#### 步骤3: 发送HTTP请求
```javascript
// 请求数据结构
{
  loginAccount: "admin",
  password: "123456", 
  captcha: "ABCD",
  sessionId: "uuid-session-id"
}
```

#### 步骤4: 后端验证处理
1. **参数验证**: 检查必填字段
2. **验证码验证**: 通过Redis验证图片验证码
3. **用户查找**: 在MongoDB中查找用户
4. **密码验证**: 使用bcrypt验证密码哈希
5. **Token生成**: 生成Access Token和Refresh Token

#### 步骤5: 返回登录结果
```javascript
// 成功响应结构
{
  code: 200,
  message: "登录成功",
  data: {
    user: {
      _id: "user_id",
      loginAccount: "admin",
      email: "admin@example.com"
    },
    accessToken: "eyJhbGciOiJIUzI1NiIs...",
    refreshToken: "eyJhbGciOiJIUzI1NiIs..."
  }
}
```

#### 步骤6: 前端处理响应
1. **Redux状态更新**: 保存Token和用户信息
2. **本地存储**: 将Token存储到localStorage
3. **成功提示**: 显示登录成功消息
4. **页面跳转**: 跳转到首页

#### 步骤7: 后续请求认证
- 请求拦截器自动添加Authorization头
- 后端中间件验证Token
- Token过期时自动刷新（可选）

## 4. 安全特性

### 4.1 双Token机制
- **Access Token**: 短期有效（15分钟），用于API访问
- **Refresh Token**: 长期有效（7天），用于刷新Access Token
- **无感刷新**: Token过期时自动刷新，用户无感知

### 4.2 验证码防护
- **图片验证码**: 防止暴力破解
- **Redis存储**: 验证码临时存储，自动过期
- **一次性使用**: 验证后立即失效

### 4.3 密码安全
- **bcrypt加密**: 密码哈希存储
- **盐值随机**: 每个密码使用不同盐值
- **慢哈希**: 增加破解难度

### 4.4 请求安全
- **CORS配置**: 跨域请求控制
- **请求日志**: 记录所有请求信息
- **错误处理**: 统一错误响应格式

## 5. 部署配置

### 5.1 环境变量配置
```bash
# .env 文件
JWT_SECRET_KEY=your_super_secret_jwt_key_2024
JWT_REFRESH_SECRET_KEY=your_super_secret_refresh_key_2024
JWT_ACCESS_TOKEN_EXPIRE=900
JWT_REFRESH_TOKEN_EXPIRE=604800
MONGODB_URI=mongodb://localhost:27017/mall
REDIS_HOST=127.0.0.1
REDIS_PORT=6379
REDIS_PASSWORD=
```

### 5.2 启动命令
```bash
# 后端启动
cd backend
npm install
npm start

# 前端启动  
cd frontend
npm install
npm start
```

### 5.3 代理配置 (frontend/src/setupProxy.js)
```javascript
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(
    '/api',
    createProxyMiddleware({
      target: 'http://localhost:3001',
      changeOrigin: true,
      pathRewrite: {
        '^/api': '', // 重写路径
      },
    })
  );
};
```

## 6. 测试验证

### 6.1 功能测试
- [ ] 正常登录流程
- [ ] 错误用户名/密码
- [ ] 验证码错误
- [ ] 验证码过期
- [ ] Token自动刷新
- [ ] 登出功能

### 6.2 安全测试
- [ ] SQL注入防护
- [ ] XSS攻击防护
- [ ] CSRF攻击防护
- [ ] 暴力破解防护

### 6.3 性能测试
- [ ] 并发登录测试
- [ ] Token验证性能
- [ ] 数据库查询优化

## 7. 常见问题

### 7.1 Token过期处理
```javascript
// 在响应拦截器中处理Token过期
if (error.response?.status === 401) {
  // 清除本地Token
  removeToken();
  removeRefreshToken();
  // 跳转到登录页
  window.location.href = '/login';
}
```

### 7.2 跨域问题
```javascript
// 后端CORS配置
app.use(cors({
  origin: ['http://localhost:3000', 'http://localhost:3001'],
  credentials: true
}));
```

### 7.3 验证码不显示
- 检查后端验证码路由是否正常
- 确认Redis连接状态
- 查看浏览器网络请求

这个完整的登录功能实现了现代Web应用的安全认证需求，包含了前后端分离、JWT认证、验证码防护等核心功能。